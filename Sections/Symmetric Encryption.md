[ XCHACHA20 ]: https://doc.libsodium.org/advanced/stream_ciphers/xchacha20
[ Blake2 ]: https://www.blake2.net/
[ Key Commitment ]: https://eprint.iacr.org/2020/1491.pdf
[ PASETO ]: https://github.com/paragonie/paseto/pull/127
[ JWT ]: https://jwt.io/
[ Krypto ]: https://www.kryptor.co.uk/
[ XCHACHA20-Poly1305 ]: https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction
[ CHACHA20-Poly1305 Original ]: https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/original_chacha20-poly1305_construction
[ CHACHA20-Poly1305 IETF ]: https://datatracker.ietf.org/doc/html/rfc7539
[ Custom Encryption ]: https://github.com/Serpent27/PARSEC
[ RC4 ]: https://en.wikipedia.org/wiki/RC4
[ TripleSec ]: https://keybase.io/triplesec/
[ WireGuard ]: https://www.wireguard.com/protocol/
[ TLS 1.3 ]: https://www.davidwong.fr/tls13/
[ CHACHA20-Blake2b ]: https://github.com/samuel-lucas6/ChaCha20-BLAKE2b
[ Best Practices ]: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/best-practices.html
[ DoubleSec ]: https://github.com/samuel-lucas6/DoubleSec
[ Multi Encryption ]: https://blog.cryptographyengineering.com/2012/02/02/multiple-encryption/
[ Not Broken ]: https://eprint.iacr.org/2019/1492.pdf
[ Secret Stream ]: https://doc.libsodium.org/secret-key_cryptography/secretstream
[ Wear Out ]: https://soatok.blog/2020/12/24/cryptographic-wear-out-for-symmetric-encryption/
[ Batch Attack ]: https://blog.cr.yp.to/20151120-batchattacks.html
[ MAC Encrypt ]: https://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac
[ Cipher Agility ]: https://paragonie.com/blog/2019/10/against-agility-in-cryptography-protocols
[ ISO/IEC 7816-4 ]: https://en.wikipedia.org/wiki/Padding_(cryptography)#ISO/IEC_7816-4
[ OpenVPN ]: https://openvpn.net/
[ Constant Time ]: https://doc.libsodium.org/helpers#constant-time-test-for-equality
[ Salsa20 ]: https://en.wikipedia.org/wiki/Salsa20
[ Salsa20 Analysis ]: https://en.wikipedia.org/wiki/Salsa20#Cryptanalysis_of_Salsa20
[ CTR ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)
[ SHA3 ]: https://competitions.cr.yp.to/sha3.html
[ Counter Mode ]: https://en.wikipedia.org/wiki/Galois/Counter_Mode
[ Fewer Algorithms ]: https://en.wikipedia.org/wiki/Transport_Layer_Security#Cipher
[ JWTs ]: https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid
[ Zero Padding ]: https://en.wikipedia.org/wiki/Padding_(cryptography)#Zero_padding
[ Random Padding ]: https://en.wikipedia.org/wiki/Padding_(cryptography)#Randomized_padding
[ Deterministic Padding ]: https://en.wikipedia.org/wiki/Padding_(cryptography)#Deterministic_padding
[ Partitioning Attack ]: https://eprint.iacr.org/2020/1491.pdf
[ Libsodium Padding ]: https://doc.libsodium.org/padding#algorithm
[ AEAD Robustness ]: https://doc.libsodium.org/secret-key_cryptography/aead#robustness
[ Password Recovery ]: https://emilymstark.com/2021/02/01/padding-partitioning-oracles-and-another-hot-take-on-pakes.html
[ Deputy Attack ]: https://cloud.google.com/kms/docs/additional-authenticated-data#confused_deputy_attack_example
[ Fix ]: https://github.com/samuel-lucas6/Committing-ChaCha20-Poly1305/blob/main/src/Method%202%20-%20Separate%20Keys%20for%20ChaCha20%20and%20Robustness%20Tag/CommittingChaCha20Poly1305/ChaCha20Poly1305.cs
[ AES-SIV ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Synthetic_initialization_vector_(SIV)
[ KEM Not Enough ]: https://neilmadden.blog/2021/02/16/when-a-kem-is-not-enough/
[ XTS ]: https://en.wikipedia.org/wiki/Disk_encryption_theory#XTS
[ Insecure KDFs ]: http://stackoverflow.com/a/36780727/3823831
[ Valid Plaintext ]: https://eprint.iacr.org/2020/1456.pdf
[ Replay Attack ]: https://en.wikipedia.org/wiki/Replay_attack
[ AWS Introduction ]: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html
[ Different Messages ]: https://www.reddit.com/r/crypto/comments/opm10n/do_i_need_a_key_committing_aead_to_be_random_key/h68mq3i/
[ PURB ]: https://bford.info/pub/sec/purb.pdf
[ EStream Competition ]: https://www.ecrypt.eu.org/stream/e2-salsa20.html
[ Salsa ]: https://cr.yp.to/snuffle/salsafamily-20071225.pdf
[ CHACHA ]: https://cr.yp.to/chacha/chacha-20080128.pdf
[ Timing Vulnerability ]: https://cr.yp.to/antiforgery/cachetiming-20050414.pdf
[ CBC ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)
[ RFC2104 ]: https://datatracker.ietf.org/doc/html/rfc2104
[ Competitions ]: https://competitions.cr.yp.to/index.html
[ Incorrect 128 ]: https://pycryptodome.readthedocs.io/en/latest/src/cipher/modern.html#gcm-mode
[ Why AES Sucks ]: https://soatok.blog/2020/05/13/why-aes-gcm-sucks/
[ Nonce Reusing ]: https://eprint.iacr.org/2016/475.pdf
[ AES Limitations ]: https://doc.libsodium.org/secret-key_cryptography/aead#limitations
[ AES Side Channels ]: https://eprint.iacr.org/2009/129.pdf
[ AES Speed ]: https://doc.libsodium.org/secret-key_cryptography/aead#aes-256-gcm
[ ECB ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_(ECB)
[ RC4 Security ]: https://en.wikipedia.org/wiki/RC4#Security
[ AES-CBC ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CBC
[ AES-CTR ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)
[ CHACHA Variant ]: https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant
[ Blowfish ]: https://en.wikipedia.org/wiki/Blowfish_(cipher)
[ CAST-128 ]: https://en.wikipedia.org/wiki/CAST-128
[ GOST ]: https://en.wikipedia.org/wiki/GOST_(block_cipher)
[ Oracle Padding Attack ]: https://en.wikipedia.org/wiki/Padding_oracle_attack
[ IDEA ]: https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm
[ 3DES ]: https://en.wikipedia.org/wiki/Triple_DES
[ RC2 ]: https://en.wikipedia.org/wiki/RC2
[ Collission Attack ]: https://sweet32.info/
[ DES ]: https://en.wikipedia.org/wiki/Data_Encryption_Standard
[ One Time Pad ]: https://en.wikipedia.org/wiki/One-time_pad
[ Repeated Key ]: https://en.wikipedia.org/wiki/XOR_cipher#Use_and_security
[ XOR Cipher ]: https://en.wikipedia.org/wiki/XOR_cipher
[ CCM ]: https://en.wikipedia.org/wiki/CCM_mode
[ AEX ]: https://en.wikipedia.org/wiki/EAX_mode
[ AES-CFB ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_feedback_(CFB)
[ AES-OFB ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Output_feedback_(OFB)
[ AES-OCB ]: https://en.wikipedia.org/wiki/OCB_mode
[ Serpent ]: https://en.wikipedia.org/wiki/Serpent_(cipher)
[ Threefish ]: https://en.wikipedia.org/wiki/Threefish
[ Twofish ]: https://en.wikipedia.org/wiki/Twofish
[ Camellia ]: https://en.wikipedia.org/wiki/Camellia_(cipher)
[ RC6 ]: https://en.wikipedia.org/wiki/RC6
[ ARIA ]: https://en.wikipedia.org/wiki/ARIA_(cipher)
[ SEED ]: https://en.wikipedia.org/wiki/SEED
[ XEX ]: https://en.wikipedia.org/wiki/Disk_encryption_theory#Xor%E2%80%93encrypt%E2%80%93xor_(XEX)
[ LRW ]: https://en.wikipedia.org/wiki/Disk_encryption_theory#Liskov,_Rivest,_and_Wagner_(LRW)
[ CMC & EME ]: https://en.wikipedia.org/wiki/Disk_encryption_theory#CBC%E2%80%93mask%E2%80%93CBC_(CMC)_and_ECB%E2%80%93mask%E2%80%93ECB_(EME)
[ Disk Encryption ]: https://en.wikipedia.org/wiki/Disk_encryption_theory
[ AES-GCM-SIV ]: https://en.wikipedia.org/wiki/AES-GCM-SIV
[ Unlimited Protection ]: https://www.imperialviolet.org/2017/05/14/aesgcmsiv.html
[ Nonce Resistance ]: https://doc.libsodium.org/secret-key_cryptography/encrypted-messages#nonce-misuse-resistance
[ Short Nonces ]: https://doc.libsodium.org/secret-key_cryptography/encrypted-messages#short-nonces
[ XSalsa20-Poly1305 ]: https://doc.libsodium.org/secret-key_cryptography/secretbox







## Symmetric Encryption


#### Use 「 Ordered 」

1. [XChaCha20][ XChaCha20 ]-then-[BLAKE2b][ Blake2 ] (Encrypt-then-MAC): **if you know what you are doing**, then implementing Encrypt-then-MAC offers better security than an AEAD because it provides better security properties, such as [key commitment][ Key Commitment ], and allows for a longer authentication tag, making it more suitable for long-term storage. This combo is now being employed by [PASETO][ PASETO ], an alternative to [JWT][ JWT ], as well as my file encryption software called [Kryptor][ Krypto ]. ChaCha20 has a [higher security margin][ Not Broken ] than AES whilst also being fast in software and [constant time][ CHACHA ], meaning it’s not vulnerable to timing attacks like AES [can be][ Timing Vulnerability ]. Moreover, [Salsa20][ Salsa ], the cipher ChaCha20 was based on, underwent rigorous analysis as part of the [eSTREAM competition][ EStream Competition ], and both ChaCha20 and Salsa20 have also received [further analysis][ Salsa20 Analysis ] since then.

2. [XChaCha20-Poly1305][ XCHACHA20-Poly1305 ]: this is the gold standard for when you don’t know how to implement Encrypt-then-MAC or need maximum performance on all devices. As mentioned above, ChaCha20 has a higher security margin than AES,https://en.wikipedia.org/wiki/Threefish always runs in constant https://en.wikipedia.org/wiki/One-time_padtime, and (X)ChaCha20-Poly1305 is faster than AES-GCM without AES-NI hardware support. Note that XChaCha20-Poly1305 should be favoured over regular ChaCha20-Poly1305 in many cases because it allows for random nonces, which helps prevent nonce reuse (please see point 1 of the Notes section). If you just need a counter nonce or intend to use a unique key for encryption each time, then ChaCha20-Poly1305 is fine. Unfortunately, there are two ChaCha20-Poly1305 constructions - the original [ChaCha20-Poly1305][ CHACHA20-Poly1305 Original ] and [ChaCha20-Poly1305-IETF][ CHACHA20-Poly1305 IETF ]. The original construction is better because it has a smaller nonce, meaning it doesn’t encourage unsafe random nonces, and a larger internal counter, meaning it can encrypt more data using the same key and nonce pair (please see point 5 of the Notes section), but the IETF variant is more popular.

3. [AES-CTR][ CTR ] (or [CBC][ CBC ])-then-[HMAC][ 2104 ] (Encrypt-then-MAC): again, **if you know what you are doing**, this is superior to using an AEAD in terms of security for the reasons outlined in point 1 above. **AES-CTR should be preferred** because AES-CBC is less efficient, requires padding, and doesn't support a counter nonce. However, both AES-CTR-then-HMAC and AES-CBC-then-HMAC can be faster than AES-GCM without AES-NI hardware support. With that said, generating an IV for CBC and CTR can be a source of trouble, with CBC requiring unpredictable (aka random) IVs and CTR implementations differing in terms of nonce size and whether a random/counter nonce is safe.

4. [AES-GCM][ Counter Mode ]: the industry standard despite it not being the best and receiving some criticism. It’s easier to use correctly than Encrypt-then-MAC and faster than (X)ChaCha20-BLAKE2b, (X)ChaCha20-Poly1305, and AES-CTR-then-HMAC/AES-CBC-then-HMAC with AES-NI hardware support, but it has a weird nonce size (96-bits) that means you should use a counter nonce, [some][ Incorrect 128 ] implementations incorrectly allow 128-bit nonces (**only use a 96-bit nonce** since longer nonces get [hashed][ Why AES Sucks ], which could result in multiple nonces producing some of the same AES-CTR output), reusing a nonce is more [catastrophic][ Nonce Reusing ] than in AES-CBC for example, and there are [relatively small][ AES Limitations ] max encryption limits (e.g. ~350 GiB for a single key when using 16 KiB long messages). Furthermore, there can be [side-channels][ AES Side Channels ] in software implementations and mitigating them [reduces the speed][ AES Speed ] of the algorithm. Therefore, AES-GCM should only be used when there’s hardware support, although I strongly recommend the above algorithms instead regardless.


---

#### Avoid 「 Unordered | All Unsuitable 」

- Your own [custom][ Custom Encryption ] symmetric encryption algorithm: even experienced cryptographers design [insecure][ SHA3 ] algorithms, which is why cryptographic algorithms are thoroughly analysed by a large number of cryptanalysts, usually as part of a [competition][ Competitions ].

- [AES-ECB][ ECB ]: identical plaintext blocks get encrypted into identical ciphertext blocks, which means the algorithm lacks diffusion and fails to hide data patterns. In other words, it’s **horribly insecure**.

- [RC4][ RC4 ]: there are lots of [attacks][ RC4 Security ] against it, rendering it **horribly insecure**.

- [AES-CBC][ AES-CBC ], [AES-CTR][ AES-CTR ], [ChaCha20][ CHACHA Variant ], and other **unauthenticated ciphers without a MAC**: this allows an attacker to tamper with the ciphertext without detection and can sometimes allow for other attacks, like [padding oracle attacks][ Oracle Padding Attack ] in the case of AES-CBC.

- [Blowfish][ Blowfish ], [CAST-128][ CAST-128 ], [GOST][ GOST ], [IDEA][ IDEA ], [3DES][ 3DES ], [DES][ DES ], [RC2][ RC2 ], and **any cipher with a 64-bit block size**: a 64-bit block size means [collision attacks][ Collission Attack ] can occur after encrypting a certain amount of data using the same key. **Don’t use any algorithm with a block size less than 128-bits**. Algorithms like DES and 3DES are also very old and have small key sizes that shouldn’t be used.

- [One-time pad][ One Time Pad ]: completely impractical since the key needs to be the same size as the message, and a **true** random number generator (e.g. atmospheric noise) is required to generate the keystream for it to be impossible to decrypt. Furthermore, some people think an [XOR cipher][ XOR Cipher ] with a repeating key is equivalent to a one-time pad, which is completely false. Repeating the key is [horribly insecure][ Repeated Key ]. **Never do this**.

- [AES-CCM][ CCM ], [AES-EAX][ AEX ], [AES-CFB][ AES-CFB ], [AES-OFB][ AES-OFB ], [AES-OCB][ AES-OCB ], [Serpent][ Serpent ], [Threefish][ Threefish ], [Twofish][ Twofish ], [Camellia][ Camellia ], [RC6][ RC6 ], [ARIA][ ARIA ], [SEED][ SEED ], and other ciphers nobody uses: very few people use these because they’re worse in one way or another, except for AES-OCB, which has very good performance but is almost never used because it was patented until recently. For example, AES-CCM uses MAC-then-Encrypt and CBC-MAC, AES-EAX is slower than AES-GCM and uses OMAC, some of them are unbalanced in terms of security to performance (e.g. Serpent is slow whilst having a high security margin), some have received limited cryptanalysis, and implementations of uncommon non-AES algorithms are very rare in mainstream cryptographic libraries, with random implementations found on GitHub being less likely to be secure because these types of algorithms can be hard to implement correctly.

- [AES-XTS][ XTS ], [AES-XEX][ XEX ], [AES-LRW][ LRW ] [AES-CMC][ CMC & EME ], [AES-EME][ CMC & EME ], and other wide block/disk encryption only modes: these are not suitable for encrypting data in transit. They should **only** be used for [disk encryption][ Disk Encryption ], with **AES-XTS being preferred** since it’s popular, more secure than some other disk encryption modes, less malleable than AES-CBC and AES-CTR (tampering causes random, unpredictable changes to the plaintext), and ordinary authentication using an AEAD or Encrypt-then-MAC cannot be used for disk encryption because it would require extra storage and slow down read/write speeds, among other things.

- [AES-GCM-SIV][ AES-GCM-SIV ] and [AES-SIV][ AES-SIV ]: these [don't][ Unlimited Protection ] provide unlimited protection against nonce reuse, they're slower than regular AES-GCM, they're rarely available in cryptographic libraries, they rely on Mac-then-Encrypt, and AES-SIV uses CMAC. If you need nonce-misuse resistance, then you should ideally use XChaCha20-then-MAC or XChaCha20-Poly1305 with a randomly generated nonce or a nonce derived alongside a subkey for encryption using a MAC, as described [here][ Nonce Resistance ] and [here][ Short Nonces ]. If this isn’t possible for some reason, then use AES-GCM-SIV.

- [(X)Salsa20][ Salsa20 ] and [(X)Salsa20-Poly1305][ XSalsa20-Poly1305 ]: there’s no reason to use these when (X)ChaCha20 has [better diffusion and performance][ CHACHA ]. However, (X)Salsa20 is still [very secure][ Salsa20 Analysis ]. Also, as mentioned in point 4, you shouldn’t use (X)Salsa20 or (X)ChaCha20 on their own (without a MAC) because **authentication is extremely important**.


---

#### Notes

1. **Never reuse a nonce/IV with the same key (e.g. never hardcode a nonce/IV)**: doing so is **catastrophic** to security. You must either use a counter nonce, a KDF generated nonce/IV, or a randomly generated nonce/IV, depending on the algorithm you’re using. For instance, you should use a counter nonce (e.g. starting with 12 bytes of zeroes) with ChaCha20-Poly1305 and AES-GCM because the small nonce size (64- or 96-bits) means random nonces are **not** safe unless you're encrypting a small amount of data per key, but you can use a random or counter nonce safely with XChaCha20-Poly1305 (192-bits). Then AES-CBC **requires** an unpredictable (aka random) 128-bit IV, and some implementations of AES-CTR need a random nonce too, although most involve using a 64- or 96-bit counter nonce or you have the same problem as with AES-GCM. Note that if you always rotate the key before encrypting (**never** encrypting anything with the same key more than once), then you *can* get away with using a nonce full of zeroes (e.g. 12 bytes of zeroes for AES-GCM), but I generally wouldn’t recommend doing this, especially if you have to use a 128-bit key, which I again **don't** recommend (please see the [Symmetric Key Size](./Symmetric Keys.md) section), since this can lead to [multi-target attacks][ Batch Attack ].

2. Prepend the nonce/IV to the ciphertext: this is the recommended approach because it’s read before the ciphertext and doesn't need to be kept secret. However, if you're performing key wrapping (encrypting a key using another key), as described in point 6 below, then you could encrypt the nonce/IV too as an additional layer of protection.

3. **Never** use string variables for keys, nonces, IVs, and passwords: these parameters should **always** be byte arrays. **String keys are just passwords, meaning they're not suitable for use as keys directly** (please see the [Password Hashing/Password-Based Key Derivation](./Key Derivation - Password.md) section). Furthermore, strings are immutable (unchangeable) in many programming languages (e.g. C#, Java, JavaScript, Go, etc), meaning they can’t be zeroed out from memory (please see point 7 below).

4. **Avoid** encryption functions/APIs that include a password parameter: these often use dated or [insecure][ Insecure KDFs ] password-based KDFs that shouldn’t be used. Instead, use one of the recommended password-based KDFs yourself to derive an encryption key for an AEAD or an encryption key and MAC key for Encrypt-then-MAC.

5. AEADs often have limits on the amount of data they can safely encrypt using a single key: for AES-GCM, you can encrypt ~64 GiB using a key and nonce pair and ~350 GiB (assuming 16 KiB messages) with a single key. For ChaCha20-Poly1305-IETF, you can encrypt 256 GiB using a key and nonce pair. XChaCha20-Poly1305 and the original ChaCha20-Poly1305 constructions have no practical limit (2^64+ bytes). Make sure you follow the recommendations below to ensure that these limits are never reached.

6. Ideally, use a new key for each message (except when chunking the same message): this helps prevent [cryptographic wear-out][ Wear Out ] (using a single key to encrypt too much data), nonce reuse, and reusing keys with multiple algorithms whilst being beneficial for security in that a compromise of one key doesn’t compromise data encrypted under different keys. One common way of doing this is to randomly generate a unique data encryption key (DEK) for each message, encrypt the DEK using a key encryption key (KEK) derived using a key derivation function (KDF), and then prepend the encrypted DEK to the ciphertext. You can then decrypt the DEK and use it to decrypt the ciphertext. Alternatively, you can derive unique keys using a random salt with a KDF, although this is inefficient when using a password-based KDF since it means a delay for every message.

7. Erase secret keys from memory as soon as possible: once you’ve finished using a secret key, it should be zeroed out from memory to prevent an attacker with physical or remote access to a machine being able to retrieve it. Note that in garbage collected programming languages, such as C#, Go, and JavaScript, this is difficult to achieve because the garbage collector can copy secrets around in memory. However, *attempting* to erase sensitive data from memory is better than doing nothing.

8. Encrypt large amounts of data in (16-64 KiB) chunks: this lowers memory usage, reduces attack boundaries for AEADs, allows for more encryptions under the same key with AEADs, means that a corruption in a ciphertext might only affect one chunk rather than rendering the entire message unrecoverable, and enables the detection of tampered chunks before an entire message is sent in an online scenario. However, this is tricky to get right because you need to add and remove padding in the last chunk (e.g. using an encrypted header to store the length of padding or a padding scheme, as explained in point 13 below) and prevent chunks from being truncated (e.g. using the total ciphertext length as additional data), reordered, duplicated, or removed (e.g. using a counter nonce that's incremented for each chunk), so you should ideally use or replicate an existing API, like [secretstream()][ Secret Stream ] in libsodium.

9. **Don’t** *just* use a standardised AEAD (e.g. AES-GCM, ChaCha20-Poly1305, etc) if you’re performing password-based encryption in an online scenario: AEADs are **not** key committing, meaning they are susceptible to [partitioning oracle attacks][ Partitioning Attack ], which [speed up password recovery][ Password Recovery ]. To solve this problem, you can either use Encrypt-then-MAC following the instructions later on in this Notes section, or you can apply a fix whilst still using an AEAD. Note that both methods will be slower than not having key commitment, but it's important to prevent this attack and the other issues explained in point 10 below. The fix I'd recommend involves deriving an encryption key and a MAC key using a KDF, encrypting the message using an AEAD with the encryption key, retrieving the authentication tag from the end of the ciphertext, and prepending a MAC of the encryption key, nonce, and AEAD authentication tag to the ciphertext (e.g. `HMAC(message: encryptionKey || nonce || tag, key: macKey)`). For decryption, you derive the encryption key and MAC key again and verify the MAC in constant time (see point 17 below) before decrypting the message using the AEAD. An example of this fix can be found [here][ Fix ].

10. Standardised AEADs (e.g. AES-GCM, ChaCha20-Poly1305, AES-GCM-SIV, etc) **aren’t** [key][ AEAD Robustness ] or [message][ KEM Not Enough ] committing: the lack of key commitment means that a ciphertext can be decrypted using **multiple keys** to [different but valid plaintexts][ Valid Plaintext ]. This won't reveal the original message, but it *could* result in the corruption of data or different plaintexts that appear to be valid file formats, which is not what you want. The [AWS Encryption SDK][ AWS Introduction ] now [recommends and defaults][ Best Practices ] to using key commitment. As explained in point 9 above, this can especially cause problems when performing password-based encryption. To fix this problem, you should either use Encrypt-then-MAC instead or apply the fix for AEADs outlined above. The lack of message commitment means that an attacker who knows the key can find [other messages that have the same tag][ KEM Not Enough ], allowing them to trick two parties using the same key into believing that they received the same message when they actually [received different messages][ Different Messages ].

11. Make use of the additional data parameter in AEADs: this parameter is useful for binding context information to a ciphertext and preventing issues like [replay attacks][ Replay Attack ] and [confused deputy attacks][ Deputy Attack ]. It’s often used to authenticate things like headers, version numbers, timestamps, and message counters. Note that additional data is not part of the ciphertext; it’s just information included in the computation of the authentication tag. You either need to store additional data securely in some sort of database (e.g. in the case of a user’s email address being used as additional data) or be able to reproduce the additional data when it’s time for decryption (e.g. using a file name as additional data).

12. If an attacker knows the encryption key, then they can still decrypt an AEAD encrypted message without knowing the additional data: for example, they can use AES-CTR with the key to decrypt an AES-GCM encrypted message, ignoring the authentication tag and additional data.

13. Pad messages before encryption if you want to hide their length: stream ciphers, such as ChaCha20 and AES-CTR (used in AES-GCM), don’t perform any padding, meaning the ciphertext is the same length as the plaintext. This generally isn’t a concern for most applications, but when it is, you should use [ISO/IEC 7816-4][ ISO/IEC 7816-4 ] or [PADME][ PURB ] padding on the message before encryption and remove the padding after decryption. This padding algorithm is [more resistant to some types of attacks][ Libsodium Padding ] than other padding algorithms and always reversible, unlike [zero padding][ Zero Padding ]. Such padding can be [randomised][ Random Padding ] or [deterministic][ Deterministic Padding ], with both techniques having pros and cons. Encrypting data in chunks, as described in point 8 above, is an example of deterministic padding since the last chunk will always be padded to the size of a chunk.

14. Stick to **Encrypt-then-MAC**: **don’t** MAC-then-Encrypt or Encrypt-and-MAC because both can be susceptible to attacks, whereas Encrypt-then-MAC is [always secure][ MAC Encrypt ] when implemented correctly. Encrypt-then-MAC is the standard approach and is what’s used in non-SIV (aka most) AEADs. The only exception to this rule is when implementing an SIV AEAD to have nonce-misuse resistance, but you should ideally let a library do that for you.

15. **Always** use separate keys for authentication and encryption: this is considered good practice, even though reusing the same key *can* be theoretically fine. In the case of a password-based KDF, this can be done by using a larger output length (e.g. 96 bytes) and splitting the output into two keys (e.g. 256-bit and 512-bit). In the case of a non-password-based KDF, you can use the KDF twice with the same input keying material but different context information, salts, and output lengths for domain separation. Please see the [Symmetric Key Size](./Symmetric Keys.md) section for details on what key size you should use for MACs.

16. **Always** MAC the nonce/IV (and everything in the message – e.g. file headers too): if you fail to authenticate the nonce/IV, then an attacker can tamper with it undetected. AEADs always authenticate the nonce for this reason.

17. **Always** compare secrets and MACs in constant time: if you don’t compare the authentication tags in constant time, then this can lead to timing attacks that allow an attacker to calculate a valid tag for a forged message. Libraries like libsodium have [constant time comparison functions][ Constant Time ] that you can use to prevent this.

18. Concatenating multiple variable length parameters when using a MAC (e.g. `HMAC(message: additionalData || ciphertext, key: macKey)`) can lead to **attacks**: please see point 5 of the [Message Authentication Codes](./Message Authentication.md) Notes section.

19. Cipher agility is [harmful][ Cipher Agility ]: less is more in the case of supporting multiple ciphers/algorithms because more choices means more can go wrong, which is one reason why [WireGuard][ WireGuard ] is regarded as superior to [OpenVPN][ OpenVPN ] and TLS 1.3 supports [fewer algorithms][ Fewer Algorithms ] than TLS 1.2. Cipher agility has caused serious problems, like in the case of [JWTs][ JWTs ]. Also, in the case of programs like GPG and VeraCrypt, customisation can allow the user to worsen their security. Therefore, **choose one secure Encrypt-then-MAC combo or AEAD recommended above, and that’s it**. If the algorithm you chose gets broken, which is **extremely** unlikely if you’re following these guidelines, then you can just increment the protocol/format version number and switch to a different algorithm.

20. Cascade encryption is unnecessary: although I’ve written a cascade encryption library based on [TripleSec][ TripleSec ] called [DoubleSec][ DoubleSec ], cascade encryption is significantly slower and solves a problem that pretty much [doesn’t exist][ Multi Encryption ] because algorithms like ChaCha20 and AES are [nowhere near broken][ Not Broken ] and other issues are more likely to cause problems. Furthermore, it’s a hassle to implement yourself compared to using a single algorithm, with more things that can go wrong. Therefore, unless you’re extremely paranoid (e.g. in an Edward Snowden type situation) and don’t care about speed at all, please don’t bother.


---

#### Discussion

Not everyone will agree with my recommendation to use Encrypt-then-MAC over AEADs when possible for the following reasons:

1. It’s easier to implement an AEAD: you don’t need to worry about deriving separate keys, appending and removing the tag, and comparing authentication tags in constant time. AEADs also make it easy to use additional data in the calculation of the tag. This should mean fewer mistakes.

2. AEADs are typically faster: AES-GCM with AES-NI instruction set support is very fast, AES-OCB is even faster, and ChaCha20-Poly1305 is also fast without the reliance on hardware support.

3. It’s easier to chunk data with an AEAD: Encrypt-then-MAC normally involves encrypting all the data in one go and appending one authentication tag at the end, which requires loading the entire message into memory and means a corruption renders the entire message unrecoverable. Whilst you can also do this with AEADs, it's recommended to chunk messages, as explained in point 8 of the Notes, meaning the ciphertext contains multiple authentication tags. This is trickier with Encrypt-then-MAC unless you're using a library that offers it as a function.

My response to these arguments is:

1. Yes, AEADs are simpler, which is exactly why we need committing AEADs and Encrypt-then-MAC implementations to be standardised and included in cryptographic libraries. Unfortunately, this isn’t happening because everyone is busy promoting non-committing AEADs.

2. Whilst this is often true, except for AES-GCM without AES-NI support, Encrypt-then-MAC, especially using MACs like BLAKE2b and BLAKE3, is not slow enough for this to be considered a serious problem, particularly in non-interactive/offline scenarios or when dealing with long-term storage. In fact, using BLAKE3 with a large enough amount of data can be faster than Poly1305 and GMAC. Moreover, I would argue that the additional security makes up for the loss in speed. (X)ChaCha20-Poly1305 and AES-GCM are not designed for long-term storage, whereas Encrypt-then-MAC is.

3. This is another reason why Encrypt-then-MAC implementations like (X)ChaCha20-BLAKE2b should be included in cryptographic libraries. If they were, then you could call it like any other AEAD. For instance, I made a [ChaCha20-BLAKE2b][ CHACHA20-Blake2b ] library to allow me to do this.

So when should you use an AEAD? Exceptions to my Encrypt-then-MAC recommendation include when:

1. Maximum performance is necessary when using public-key cryptography: for example, in online scenarios that don’t involve passwords and storing data long-term, such as [TLS 1.3][ TLS 1.3 ] and [WireGuard][ WireGuard ]. This is what AEADs are designed for.

2. You’re not comfortable implementing Encrypt-then-MAC: if there’s no decent library you can use (e.g. Tink isn’t available in your language) or copy code from (make sure you respect the code license!), then you’re more likely to implement an AEAD correctly. However, implementing the fix I recommend for partitioning oracle attacks (please see point 9 of the Notes), which affect online password-based encryption scenarios, requires knowing how to use a MAC, so at that point, you may as well use Encrypt-then-MAC, especially if you’re storing data long-term. The lack of key commitment could also *theoretically* lead to data loss even when partitioning oracle attacks aren't a threat (e.g. in offline scenarios), meaning you should also implement the fix if that concerns you, like Amazon has for their [Encryption SDK][ Best Practices ]. With enough research and attention to detail, Encrypt-then-MAC can be implemented correctly by anyone.
