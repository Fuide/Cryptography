
[ XCHACHA20 ]: https://doc.libsodium.org/advanced/stream_ciphers/xchacha20
[ Blake2 ]: https://www.blake2.net/
[ Key Commitment ]: https://eprint.iacr.org/2020/1491.pdf
[ PASETO ]: https://github.com/paragonie/paseto/pull/127
[ JWT ]: https://jwt.io/
[ Krypto ]: https://www.kryptor.co.uk/
[ XCHACHA20-Poly1305 ]: https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction
[ CHACHA20-Poly1305 Original ]: https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/original_chacha20-poly1305_construction
[ CHACHA20-Poly1305 IETF ]: https://datatracker.ietf.org/doc/html/rfc7539
[ Custom Encryption ]: https://github.com/Serpent27/PARSEC
[ RC4 ]: https://en.wikipedia.org/wiki/RC4
[ TripleSec ]: https://keybase.io/triplesec/
[ WireGuard ]: https://www.wireguard.com/protocol/
[ TLS 1.3 ]: https://www.davidwong.fr/tls13/
[ CHACHA20-Blake2b ]: https://github.com/samuel-lucas6/ChaCha20-BLAKE2b
[ Best Practices ]: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/best-practices.html
[ DoubleSec ]: https://github.com/samuel-lucas6/DoubleSec
[ Multi Encryption ]: https://blog.cryptographyengineering.com/2012/02/02/multiple-encryption/
[ Not Broken ]: https://eprint.iacr.org/2019/1492.pdf
[ Secret Stream ]: https://doc.libsodium.org/secret-key_cryptography/secretstream
[ Wear Out ]: https://soatok.blog/2020/12/24/cryptographic-wear-out-for-symmetric-encryption/
[ Batch Attack ]: https://blog.cr.yp.to/20151120-batchattacks.html
[ MAC Encrypt ]: https://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac
[ Cipher Agility ]: https://paragonie.com/blog/2019/10/against-agility-in-cryptography-protocols
[ ISO/IEC 7816-4 ]: https://en.wikipedia.org/wiki/Padding_(cryptography)#ISO/IEC_7816-4
[ OpenVPN ]: https://openvpn.net/
[ Constant Time ]: https://doc.libsodium.org/helpers#constant-time-test-for-equality
[ Salsa20 ]: https://en.wikipedia.org/wiki/Salsa20
[ Salsa20 Analysis ]: https://en.wikipedia.org/wiki/Salsa20#Cryptanalysis_of_Salsa20
[ CTR ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)
[ SHA3 ]: https://competitions.cr.yp.to/sha3.html
[ Counter Mode ]: https://en.wikipedia.org/wiki/Galois/Counter_Mode
[ Fewer Algorithms ]: https://en.wikipedia.org/wiki/Transport_Layer_Security#Cipher
[ JWTs ]: https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid
[ Zero Padding ]: https://en.wikipedia.org/wiki/Padding_(cryptography)#Zero_padding
[ Random Padding ]: https://en.wikipedia.org/wiki/Padding_(cryptography)#Randomized_padding
[ Deterministic Padding ]: https://en.wikipedia.org/wiki/Padding_(cryptography)#Deterministic_padding
[ Partitioning Attack ]: https://eprint.iacr.org/2020/1491.pdf
[ Libsodium Padding ]: https://doc.libsodium.org/padding#algorithm
[ AEAD Robustness ]: https://doc.libsodium.org/secret-key_cryptography/aead#robustness
[ Password Recovery ]: https://emilymstark.com/2021/02/01/padding-partitioning-oracles-and-another-hot-take-on-pakes.html
[ Deputy Attack ]: https://cloud.google.com/kms/docs/additional-authenticated-data#confused_deputy_attack_example
[ Fix ]: https://github.com/samuel-lucas6/Committing-ChaCha20-Poly1305/blob/main/src/Method%202%20-%20Separate%20Keys%20for%20ChaCha20%20and%20Robustness%20Tag/CommittingChaCha20Poly1305/ChaCha20Poly1305.cs
[ KEM Not Enough ]: https://neilmadden.blog/2021/02/16/when-a-kem-is-not-enough/
[ Insecure KDFs ]: http://stackoverflow.com/a/36780727/3823831
[ Valid Plaintext ]: https://eprint.iacr.org/2020/1456.pdf
[ Replay Attack ]: https://en.wikipedia.org/wiki/Replay_attack
[ AWS Introduction ]: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html
[ Different Messages ]: https://www.reddit.com/r/crypto/comments/opm10n/do_i_need_a_key_committing_aead_to_be_random_key/h68mq3i/
[ PURB ]: https://bford.info/pub/sec/purb.pdf
[ EStream Competition ]: https://www.ecrypt.eu.org/stream/e2-salsa20.html
[ Salsa ]: https://cr.yp.to/snuffle/salsafamily-20071225.pdf
[ CHACHA ]: https://cr.yp.to/chacha/chacha-20080128.pdf
[ Timing Vulnerability ]: https://cr.yp.to/antiforgery/cachetiming-20050414.pdf
[ CBC ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)
[ RFC2104 ]: https://datatracker.ietf.org/doc/html/rfc2104
[ Competitions ]: https://competitions.cr.yp.to/index.html
[ Incorrect 128 ]: https://pycryptodome.readthedocs.io/en/latest/src/cipher/modern.html#gcm-mode
[ Nonce Reusing ]: https://eprint.iacr.org/2016/475.pdf

[ Why AES Sucks ]: https://soatok.blog/2020/05/13/why-aes-gcm-sucks/
[ AES-SIV ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Synthetic_initialization_vector_(SIV)
[ AES Limitations ]: https://doc.libsodium.org/secret-key_cryptography/aead#limitations
[ AES Side Channels ]: https://eprint.iacr.org/2009/129.pdf
[ AES Speed ]: https://doc.libsodium.org/secret-key_cryptography/aead#aes-256-gcm
[ AES-CTR ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)
[ AES-CBC ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CBC

[ AES-CFB ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_feedback_(CFB)
[ AES-OFB ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Output_feedback_(OFB)
[ AES-OCB ]: https://en.wikipedia.org/wiki/OCB_mode
[ AES-CCM ]: https://en.wikipedia.org/wiki/CCM_mode
[ AES-EAX ]: https://en.wikipedia.org/wiki/EAX_mode

[ AES-XTS ]: https://en.wikipedia.org/wiki/Disk_encryption_theory#XTS
[ AES-XEX ]: https://en.wikipedia.org/wiki/Disk_encryption_theory#Xor%E2%80%93encrypt%E2%80%93xor_(XEX)
[ AES-LRW ]: https://en.wikipedia.org/wiki/Disk_encryption_theory#Liskov,_Rivest,_and_Wagner_(LRW)
[ AES-CMC ]: https://en.wikipedia.org/wiki/Disk_encryption_theory#CBC%E2%80%93mask%E2%80%93CBC_(CMC)_and_ECB%E2%80%93mask%E2%80%93ECB_(EME)
[ AES-EME ]: https://en.wikipedia.org/wiki/Disk_encryption_theory#CBC%E2%80%93mask%E2%80%93CBC_(CMC)_and_ECB%E2%80%93mask%E2%80%93ECB_(EME)

[ RC4 Security ]: https://en.wikipedia.org/wiki/RC4#Security
[ CHACHA Variant ]: https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant
[ Blowfish ]: https://en.wikipedia.org/wiki/Blowfish_(cipher)
[ Oracle Padding Attack ]: https://en.wikipedia.org/wiki/Padding_oracle_attack
[ Collission Attack ]: https://sweet32.info/

[ CAST-128 ]: https://en.wikipedia.org/wiki/CAST-128
[ GOST ]: https://en.wikipedia.org/wiki/GOST_(block_cipher)
[ IDEA ]: https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm
[ 3DES ]: https://en.wikipedia.org/wiki/Triple_DES
[ RC2 ]: https://en.wikipedia.org/wiki/RC2
[ DES ]: https://en.wikipedia.org/wiki/Data_Encryption_Standard

[ ECB ]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_(ECB)
[ One Time Pad ]: https://en.wikipedia.org/wiki/One-time_pad
[ Repeated Key ]: https://en.wikipedia.org/wiki/XOR_cipher#Use_and_security
[ XOR Cipher ]: https://en.wikipedia.org/wiki/XOR_cipher

[ Serpent ]: https://en.wikipedia.org/wiki/Serpent_(cipher)
[ Threefish ]: https://en.wikipedia.org/wiki/Threefish
[ Twofish ]: https://en.wikipedia.org/wiki/Twofish
[ Camellia ]: https://en.wikipedia.org/wiki/Camellia_(cipher)
[ RC6 ]: https://en.wikipedia.org/wiki/RC6
[ ARIA ]: https://en.wikipedia.org/wiki/ARIA_(cipher)
[ SEED ]: https://en.wikipedia.org/wiki/SEED
[ Disk Encryption ]: https://en.wikipedia.org/wiki/Disk_encryption_theory
[ AES-GCM-SIV ]: https://en.wikipedia.org/wiki/AES-GCM-SIV
[ Unlimited Protection ]: https://www.imperialviolet.org/2017/05/14/aesgcmsiv.html
[ Nonce Resistance ]: https://doc.libsodium.org/secret-key_cryptography/encrypted-messages#nonce-misuse-resistance
[ Short Nonces ]: https://doc.libsodium.org/secret-key_cryptography/encrypted-messages#short-nonces
[ XSalsa20-Poly1305 ]: https://doc.libsodium.org/secret-key_cryptography/secretbox

[ Overview ]: ../Overview


# Symmetric Encryption
##### 「[ Overview ]」

<br>
<br>
<br>


## **Recommended** 「 In Order 」

<br>

### [XChaCha20][ XChaCha20 ] ➜ [BLAKE2b][ Blake2 ]

`Encrypt ➜ MAC`

**If you know what you are doing**, then implementing `Encrypt ➜ MAC` offers better security than<br>
an **AEAD** because it provides better security properties, such as [key commitment][ Key Commitment ], and allows for a<br>
longer authentication tag, making it more suitable for long-term storage.

This combo is now being employed by [PASETO][ PASETO ], an alternative<br>
to [JWT][ JWT ], as well as my file encryption software called [Kryptor][ Krypto ].

**ChaCha20** has a [higher security margin][ Not Broken ] than **AES** whilst also being fast in software<br>
and [constant time][ CHACHA ], meaning it’s not vulnerable to timing attacks like **AES** [can be][ Timing Vulnerability ].

Moreover, [Salsa20][ Salsa ], the cipher **ChaCha20** was based on, underwent rigorous<br>
analysis as part of the [eSTREAM competition][ EStream Competition ], and both **ChaCha20** and **Salsa20**<br>
have also received [further analysis][ Salsa20 Analysis ] since then.

---

### [XChaCha20-Poly1305][ XCHACHA20-Poly1305 ]

This is the gold standard for when you don’t know how to implement<br>
`Encrypt ➜ MAC` or need maximum performance on all devices.

As mentioned above, **ChaCha20** has a higher security margin than **AES**, always runs in constant<br>
time, and **(X)ChaCha20-Poly1305** is faster than **AES-GCM** without **AES-NI** hardware support.

Note that **XChaCha20-Poly1305** should be favored over regular<br>
**ChaCha20-Poly1305** in many cases because it allows for random<br>
nonces, which helps prevent nonce reuse (please see note **1**).

If you just need a counter nonce or intend to use a unique key for encryption each time,<br>
then **ChaCha20-Poly1305** is fine. Unfortunately, there are two **ChaCha20-Poly1305**<br>
constructions - the original [ChaCha20-Poly1305][ CHACHA20-Poly1305 Original ] and [ChaCha20-Poly1305-IETF][ CHACHA20-Poly1305 IETF ].

The original construction is better because it has a smaller nonce, meaning<br>
it doesn’t encourage unsafe random nonces, and a larger internal counter,<br>
meaning it can encrypt more data using the same key and nonce pair<br>
(please see note **5**), but the **IETF** variant is more popular.

---

### ( [AES-CTR][ CTR ] | [CBC][ CBC ] ) ➜ [HMAC][ RFC2104 ]

`Encrypt ➜ MAC`

Again, **if you know what you are doing**, this is superior to using an<br>
**AEAD** in terms of security for the reasons outlined in point **1** above.

**AES-CTR should be preferred** because **AES-CBC** is less efficient,<br>
requires padding, and doesn't support a counter nonce.

However, both **AES-CTR-then-HMAC** and **AES-CBC-then-HMAC**<br>
can be faster than **AES-GCM** without **AES-NI** hardware support.

With that said, generating an IV for **CBC** and **CTR** can be a source of trouble,<br>
with **CBC** requiring unpredictable (aka random) IVs and **CTR** implementations<br>
differing in terms of nonce size and whether a random / counter nonce is safe.

---

### [AES-GCM][ Counter Mode ]

The industry standard despite it not being the best and receiving some criticism.

It’s easier to use correctly than **Encrypt-then-MAC** and faster than **(X)ChaCha20-BLAKE2b**,<br>
**(X)ChaCha20-Poly1305**, and **AES-CTR-then-HMAC/AES-CBC-then-HMAC** with **AES-NI** hardware<br>
support, but it has a weird nonce size (**96-bits**) that means you should use a counter nonce,<br>
[some][ Incorrect 128 ] implementations incorrectly allow **128-bit** nonces (**only use a 96-bit nonce** since longer<br>
nonces get [hashed][ Why AES Sucks ], which could result in multiple nonces producing some of the same **AES-CTR**<br>
output), reusing a nonce is more [catastrophic][ Nonce Reusing ] than in **AES-CBC** for example, and there are<br>
[relatively small][ AES Limitations ] max encryption limits (e.g. **~350 GiB** for a single key when using<br>
**16 KiB** long messages).

Furthermore, there can be [side-channels][ AES Side Channels ] in software implementations<br>
and mitigating them [reduces the speed][ AES Speed ] of the algorithm.

Therefore, **AES-GCM** should only be used when there’s hardware support,<br>
although I strongly recommend the above algorithms instead regardless.


<br>
<br>
<br>


## **Avoid** 「 Unordered | All Unsuitable 」

<br>

### Your own [custom][ Custom Encryption ] symmetric encryption algorithm

Even experienced cryptographers design [insecure][ SHA3 ] algorithms, which<br>
is why cryptographic algorithms are thoroughly analysed by a large<br>
number of< cryptanalysts, usually as part of a [competition][ Competitions ].

---

### [AES-ECB][ ECB ]

Identical plaintext blocks get encrypted into identical ciphertext blocks,<br>
which means the algorithm lacks diffusion and fails to hide data patterns.

In other words, it’s **horribly insecure**.

---

### [RC4][ RC4 ]

There are lots of [attacks][ RC4 Security ] against it, rendering it **horribly insecure**.

---

### 〔 [ AES-CBC ] 〕〔 [ AES-CTR ] 〕〔 [ChaCha20][ CHACHA Variant ] 〕

**And other unauthenticated ciphers without a MAC**

This allows an attacker to tamper with the ciphertext without detection and can<br>
sometimes allow for other attacks, like [padding oracle attacks][ Oracle Padding Attack ] in the case of **AES-CBC**.

---

### 〔 [ DES ] 〕〔 [ GOST ] 〕〔 [ Blowfish ] 〕〔 [ 3DES ] 〕<br>〔 [ RC2 ] 〕〔 [ IDEA ] 〕〔 [ CAST-128 ] 〕

**And Any Other 64-bit Block Cipher**

A **64-bit** block size means [collision attacks][ Collission Attack ] can occur after<br>
encrypting a certain amount of data using the same key.

**Don’t use any algorithm with a block size less than 128-bits**.

Algorithms like **DES** and **3DES** are also very old<br>
and have small key sizes that aren't secure.

---

### [One-time pad][ One Time Pad ]

Completely impractical since the key needs to be the same size as the message,<br>
and a **true** random number generator (atmospheric noise) is required to<br>
generate the keystream for it to be impossible to decrypt.

Furthermore, some people think an [XOR cipher][ XOR Cipher ] with a repeating key is equivalent<br>
to a one-time pad, which is completely false. Repeating the key is [horribly insecure][ Repeated Key ].

**Never do this**.

---

### AES - ( [ CCM ][ AES-CCM ] | [ AEX ][ AES-EAX ] | [ CFB ][ AES-CFB ] | [OCB][ AES-OCB ] ) 〔 [ Twofish ] 〕〔 [ Threefish ] 〕<br>〔 [ RC6 ] 〕 〔 [ ARIA ] 〕 〔 [ SEED ] 〕 〔 [ Serpent ] 〕 〔 [ Camellia ] 〕

**And Other Ciphers Nobody Uses**

Very few people use these because they’re worse in one way or another, except for **AES-OCB**,<br>
which has very good performance but is almost never used because it was patented until recently.

For example, **AES-CCM** uses **MAC-then-Encrypt** and **CBC-MAC**, **AES-EAX** is slower than **AES-GCM**<br>
and uses **OMAC**, some of them are unbalanced in terms of security to performance (**Serpent**<br>
is slow whilst having a high security margin), some have received limited cryptanalysis,<br>
and implementations of uncommon non-**AES** algorithms are very rare in mainstream<br>
cryptographic libraries, with random implementations found on GitHub being less<br>
likely to be secure because these types of algorithms can be hard to implement correctly.

---

### AES - ( [XTS][ AES-XTS ] | [XEX][ AES-XEX ] | [LRW][ AES-LRW ] | [CMC][ AES-CMC ] | [EME][ AES-EME ] )

**and other wide block/disk encryption only modes**

These are not suitable for encrypting data in transit.

They should **only** be used for [disk encryption][ Disk Encryption ], with **AES-XTS being preferred** since it’s popular,<br>
more secure than some other disk encryption modes, less malleable than **AES-CBC** and **AES-CTR**<br>
(tampering causes random, unpredictable changes to the plaintext), and ordinary authentication<br>
using an **AEAD** or `Encrypt ➜ MAC` cannot be used for disk encryption because it would require<br>
extra storage and slow down read / write speeds, among other things.

---

### AES - ( [GCM-SIV][ AES-GCM-SIV ] | [SIV][ AES-SIV ] )

These [don't][ Unlimited Protection ] provide unlimited protection against nonce reuse, they're slower<br>
than regular **AES-GCM**, they're rarely available in cryptographic libraries, they<br>
rely on `MAC ➜ Encrypt`, and **AES-SIV** uses **CMAC**.

If you need nonce-misuse resistance, then you should ideally use `XCHACHA20 ➜ MAC`<br>
or **XChaCha20-Poly1305** with a randomly generated nonce or a nonce derived alongside<br>
a subkey for encryption using a **KDF** or **MAC**, as described [here][ Nonce Resistance ] and [here][ Short Nonces ].

If this isn’t possible for some reason, then use **AES-GCM-SIV**.

---

### (X)Salsa ( [20][ Salsa20 ] | [20-Poly1305][ XSalsa20-Poly1305 ] )

There’s no reason to use these when **(X)ChaCha20**<br>
has [better diffusion and performance][ CHACHA ].

However, **(X)Salsa20** is still [very secure][ Salsa20 Analysis ].

Also, as mentioned in point **4**, you shouldn’t use **(X)Salsa20** <br>
on it's own (without a **MAC**) because **authentication is extremely important**.


<br>
<br>
<br>


#### **Notes**

<br>

「 **1** 」

**Never reuse a nonce / IV with the same key (never hardcode a nonce / IV)**

Doing so is **catastrophic** to security.

You must either use a counter nonce, a **KDF** generated nonce / IV, or a<br>
randomly generated nonce/IV,depending on the algorithm you’re using.

For instance, you should use a counter nonce (starting with **12 bytes** of zeroes)<br>
with **ChaCha20-Poly1305** and **AES-GCM** because the small nonce size<br>
(**64 or 96-bits**) means random nonces are **not** safe unless you're<br>
encrypting a small amount of data per key, but you can use a random<br>
or counter nonce safely with **XChaCha20-Poly1305** (**192-bits**).

Then **AES-CBC** **requires** an unpredictable (aka random) **128-bit** IV, and some<br>
implementations of **AES-CTR** need a random nonce too, although most involve<br>
using a **64 or 96-bit** counter nonce or you have the same problem as with **AES-GCM**.

Note that if you always rotate the key before encrypting (**never** encrypting anything with<br>
the same key more than once), then you *can* get away with using a nonce full of zeroes<br>
(**12 bytes** of zeroes for **AES-GCM**), but I generally wouldn’t recommend doing this,<br>
especially if you have to use a **128-bit** key, which I again **don't** recommend<br>
(please see the [Symmetric Key Size](./Symmetric%20Keys) section), since this can lead to [multi-target attacks][ Batch Attack ].

---

「 **2** 」

Prepend the nonce / IV to the ciphertext

This is the recommended approach because it’s read<br>
before the ciphertext and doesn't need to be kept secret.

However, if you're performing key wrapping (encrypting a key using another key),<br>
as described in point **6** below, then you could encrypt the nonce / IV too as an<br>
additional layer of protection.

---

「 **3** 」

**Never** use string variables for keys, nonces, IVs, and passwords

These parameters should **always** be byte arrays.

**String keys are just passwords, meaning they're not suitable for use as keys directly**<br>
↳ [ `Please see the Password-Based Key Derivation section`](./Key%20Derivation%20-%20Password)

Furthermore, strings are immutable (unchangeable) in many programming<br>
languages (**C#**, **Java**, **JavaScript**, **Go**, .. ), meaning they can’t be zeroed out<br>
from memory (please see point **7** below).

---

「 **4** 」

**Avoid** encryption functions / APIs that include a password parameter

These often use dated or [insecure][ Insecure KDFs ] password-based **KDFs** that shouldn’t be used.

Instead, use one of the recommended password-based **KDFs** yourself to derive an<br>
encryption key for an **AEAD** or an encryption key and **MAC** key for `Encrypt ➜ MAC`.

---

「 **5** 」

**AEADs** often have limits on the amount of data they can safely encrypt using a single key

For **AES-GCM**, you can encrypt **~64 GiB** using a key and nonce<br>
pair and **~350 GiB** (assuming **16 KiB** messages) with a single key.

For **ChaCha20-Poly1305-IETF**, you can encrypt **256 GiB** using a key and nonce pair.

**XChaCha20-Poly1305** and the original **ChaCha20-Poly1305**<br>
constructions have no practical limit (**2^64+ bytes**).

Make sure you follow the recommendations below to ensure that these limits are never reached.

---

「 **6** 」

Ideally, use a new key for each message (except when chunking the same message)

This helps prevent [cryptographic wear-out][ Wear Out ] (using a single key to encrypt too much data),<br>
nonce reuse, and reusing keys with multiple algorithms whilst being beneficial for security<br>
in that a compromise of one key doesn’t compromise data encrypted under different keys.

One common way of doing this is to randomly generate a unique data encryption key<br>
(**DEK**) for each message, encrypt the **DEK** using a key encryption key (**KEK**) derived using<br>
a key derivation function (**KDF**), and then prepend the encrypted **DEK** to the ciphertext.

You can then decrypt the **DEK** and use it to decrypt the ciphertext.

Alternatively, you can derive unique keys using a random salt with a **KDF**, although this<br>
is inefficient when using a password-based **KDF** since it means a delay for every message.

---

「 **7** 」

Erase secret keys from memory as soon as possible

Once you’ve finished using a secret key, it should be zeroed out from memory to prevent<br>
an attacker with physical or remote access to a machine being able to retrieve it.

Note that in garbage collected programming languages, such as **C#**, **Go**, and **JavaScript**,<br>
this is difficult to achieve because the garbage collector can copy secrets around in memory.

However, *attempting* to erase sensitive data from memory is better than doing nothing.

---

「 **8** 」

Encrypt large amounts of data in (**16 - 64 KiB**) chunks

This lowers memory usage, reduces attack boundaries for **AEADs**,<br>
allows for more encryptions under the same key with **AEADs**, means<br>
that a corruption in a ciphertext might only affect one chunk rather<br>
than rendering the entire message unrecoverable, and enables the<br>
detection of tampered chunks before an entire message is sent in<br>
an online scenario.

However, this is tricky to get right because you need to add and remove<br>
padding in the last chunk (using an encrypted header to store the length<br>
of padding or a padding scheme, as explained in point **13** below) and<br>
prevent chunks from being truncated (using the total ciphertext length<br>
as additional data), reordered, duplicated, or removed (using a counter<br>
nonce that's incremented for each chunk), so you should ideally use or<br>
replicate an existing API, like [secretstream()][ Secret Stream ] in **Libsodium**.

---

「 **9** 」

**Don’t** *just* use a standardised **AEAD** (**AES-GCM**, **ChaCha20-Poly1305**, .. )<br>
if you’re performing password-based encryption in an online scenario

**AEADs** are **not** key committing, meaning they are susceptible to<br>
[partitioning oracle attacks][ Partitioning Attack ], which [speed up password recovery][ Password Recovery ].

To solve this problem, you can either use `Encrypt ➜ MAC` following the instructions<br>
later on in this Notes section, or you can apply a fix whilst still using an **AEAD**.

Note that both methods will be slower than not having key commitment, but it's<br>
important to prevent this attack and the other issues explained in point **10** below.

The fix I'd recommend involves deriving an encryption key and a **MAC** key using a **KDF**,<br>
encrypting the message using an **AEAD** with the encryption key, retrieving the<br>
authentication tag from the end of the ciphertext, and prepending a **MAC** of the<br>
encryption key, nonce, and **AEAD** authentication tag to the ciphertext.

`HMAC( Message : Encryption Key | Nonce | Tag , Key : Mac Key )`

<br>

For decryption, you derive the encryption key and **MAC** key again and verify the **MAC**<br>
in constant time (see point **17** below) before decrypting the message using the **AEAD**.

An example of this fix can be found [here][ Fix ].

---

「 **10** 」

Standardised **AEADs** (**AES-GCM**, **ChaCha20-Poly1305**, **AES-GCM-SIV**, .. )<br>
**aren’t** [key][ AEAD Robustness ] or [message][ KEM Not Enough ] committing

The lack of key commitment means that a ciphertext can be<br>
decrypted using **multiple keys** to [different but valid plaintexts][ Valid Plaintext ].

This won't reveal the original message, but it *could* result in the corruption of data or<br>
different plaintexts that appear to be valid file formats, which is not what you want.

The [AWS Encryption SDK][ AWS Introduction ] now [recommends and defaults][ Best Practices ] to using key commitment.

As explained in point **9** above, this can especially cause<br>
problems when performing password-based encryption.

To fix this problem, you should either use `Encrypt ➜ MAC`<br>
instead or apply the fix for **AEADs** outlined above.

The lack of message commitment means that an attacker who knows<br>
the key can find [other messages that have the same tag][ KEM Not Enough ], allowing them<br>
to trick two parties using the same key into believing that they received<br>
the same message when they actually [received different messages][ Different Messages ].

---

「 **11** 」

Make use of the additional data parameter in **AEADs**

This parameter is useful for binding context information to a ciphertext<br>
and preventing issues like [replay attacks][ Replay Attack ] and [confused deputy attacks][ Deputy Attack ].

It’s often used to authenticate things like headers,<br>
version numbers, timestamps, and message counters.

Note that additional data is not part of the ciphertext; it’s just<br>
information, included in the computation of the authentication tag.

You either need to store additional data securely in some sort of database<br>
(in the case of a user’s email address being used as additional data) or be<br>
able to reproduce the additional data when it’s time for decryption<br>
(using a file name as additional data).

---

「 **12** 」

If an attacker knows the encryption key, then they can still decrypt<br>
an **AEAD** encrypted message without knowing the additional data

For example, they can use **AES-CTR** with the key to decrypt an **AES-GCM**<br>
encrypted message, ignoring the authentication tag and additional data.

---

「 **13** 」

Pad messages before encryption if you want to hide their length

Stream ciphers, such as **ChaCha20** and **AES-CTR** (used in **AES-GCM**), don’t perform<br>
any padding, meaning the ciphertext is the same length as the plaintext.

This generally isn’t a concern for most applications, but when it is,<br>
you should use [ ISO/IEC 7816-4 ] or [PADME][ PURB ] padding on the message<br>
before encryption and remove the padding after decryption.

This padding algorithm is [more resistant to some types of attacks][ Libsodium Padding ] than<br>
other padding algorithms and always reversible, unlike [ Zero Padding ].

Such padding can be [randomised][ Random Padding ] or [deterministic][ Deterministic Padding ], with both techniques having pros and cons.

Encrypting data in chunks, as described in point **8** above, is an example of deterministic<br>
padding since the last chunk will always be padded to the size of a chunk.

---

「 **14** 」

**Stick to `Encrypt ➜ MAC`**

**Don’t** `MAC ➜ Encrypt` or `Encrypt + MAC` because both can be susceptible to<br>
attacks, whereas `Encrypt ➜ MAC` is [always secure][ MAC Encrypt ] when implemented correctly.

`Encrypt ➜ MAC` is the standard approach and is what’s used in non-**SIV** (aka most) **AEADs**.

The only exception to this rule is when implementing an **SIV AEAD** to have<br>
nonce-misuse resistance, but you should ideally let a library do that for you.

---

「 **15** 」

**Always** use separate keys for authentication and encryption

This is considered good practice, even though reusing the same key *can* be theoretically fine.

In the case of a password-based **KDF**, this can be done by using a larger output<br>
length (**96 bytes**) and splitting the output into two keys (**256-bit** and **512-bit**).

In the case of a non-password-based **KDF**, you can use the **KDF**<br>
twice with the same input keying material but different context<br>
information, salts, and output lengths for domain separation.

↳ [ `Please check the Symmetric Key Size section for MAC key size`](./Symmetric%20Keys)

---

「 **16** 」

**Always** **MAC** the nonce / IV (and everything in the message – file headers too)

If you fail to authenticate the nonce / IV, then an attacker can tamper with it undetected.

**AEADs** always authenticate the nonce for this reason.

---

「 **17** 」

**Always** compare secrets and **MACs** in constant time

If you don’t compare the authentication tags in constant time, then this can lead<br>
to timing attacks that allow an attacker to calculate a valid tag for a forged message.

Libraries like **Libsodium** have [constant time comparison functions][ Constant Time ] that you can use to prevent this.

---

「 **18** 」

Concatenating multiple variable length parameters when using a **MAC** can lead to **attacks**

```
HMAC (
    Message : Additional Data | Ciphertext
    Key : Mac Key
)
```



↳ [ `Please see point 5 of the Message Authentication Codes notes`](./Message%20Authentication)

---

「 **19** 」

**Cipher Agility Is [Harmful][ Cipher Agility ]**

Less is more in the case of supporting multiple ciphers / algorithms because more<br>
choices means more can go wrong, which is one reason why [ WireGuard ] is regarded<br>
as superior to [ OpenVPN ] and **TLS 1.3** supports [ Fewer Algorithms ] than **TLS 1.2**.

Cipher agility has caused serious problems, like in the case of [ JWTs ].

Also, in the case of programs like **GPG** and **VeraCrypt**,<br>
customization can allow the user to worsen their security.

Therefore, **choose one secure `Encrypt ➜ MAC`<br>
combo or AEAD recommended above, and that’s it**.

If the algorithm you chose gets broken, which is **extremely** unlikely<br>
if you’re following these guidelines, then you can just increment the<br>
protocol / format version number and switch to a different algorithm.

---

「 **20** 」

**Cascade Encryption Is Unnecessary**

Although I’ve written a cascade encryption library based on [ TripleSec ] called [ DoubleSec ],<br>
cascade encryption is significantly slower and solves a problem that pretty much<br>
[doesn’t exist][ Multi Encryption ] because algorithms like **ChaCha20** and **AES** are [nowhere near broken][ Not Broken ]<br>
and other issues are more likely to cause problems.

Furthermore, it’s a hassle to implement yourself compared to<br>
using a single algorithm, with more things that can go wrong.

Therefore, unless you’re extremely paranoid (in an ***Edward Snowden*** type situation)<br>
and don’t care about speed at all, please don’t bother.


<br>
<br>
<br>


#### **Discussion**

<br>

Not everyone will agree with my recommendation to use<br>
`Encrypt ➜ MAC` over **AEADs** when possible for the following reasons:

<br>

「 **1** 」

It’s easier to implement an **AEAD**

You don’t need to worry about deriving separate keys, appending and<br>
removing the tag, and comparing authentication tags in constant time.

**AEADs** also make it easy to use additional data in the calculation of the tag.

This should mean fewer mistakes.

---

「 **2** 」

**AEADs** are typically faster

**AES-GCM** with **AES-NI** instruction set support is very fast,<br>
**AES-OCB** is even faster, and **ChaCha20-Poly1305** is also<br>
fast without the reliance on hardware support.

---

「 **3** 」

It’s easier to chunk data with an **AEAD**:

`Encrypt ➜ MAC` normally involves encrypting all the data in one go<br>
and appending one authentication tag at the end, which requires<br>
loading the entire message into memory and means a corruption<br>
renders the entire message unrecoverable.

Whilst you can also do this with **AEADs**, it's recommended to chunk messages, as explained<br>
in point **8** of the Notes, meaning the ciphertext contains multiple authentication tags.

This is trickier with `Encrypt ➜ MAC` unless you're using a library that offers it as a function.

---

### My Response To These Arguments

<br>

「 **1** 」

Yes, **AEADs** are simpler, which is exactly why we need committing **AEADs** and `Encrypt ➜ MAC`<br>
implementations to be standardized and included in cryptographic libraries.

Unfortunately, this isn’t happening because everyone is busy promoting non-committing **AEADs**.

---

「 **2** 」

Whilst this is often true, except for **AES-GCM** without **AES-NI** support, `Encrypt ➜ MAC`,<br>
especially using **MACs** like **BLAKE2b** and **BLAKE3**, is not slow enough for this to be<br>
considered a serious problem, particularly in non-interactive / offline scenarios or<br>
when dealing with long-term storage.

In fact, using **BLAKE3** with a large enough amount of data can be faster than **Poly1305** and **GMAC**.

Moreover, I would argue that the additional security makes up for the loss in speed.

**(X)ChaCha20-Poly1305** and **AES-GCM** are not designed<br>
for long-term storage, whereas `Encrypt ➜ MAC` is.

---

「 **3** 」

This is another reason why `Encrypt ➜ MAC` implementations like<br>
**(X)ChaCha20-BLAKE2b** should be included in cryptographic libraries.

If they were, then you could call it like any other **AEAD**.

For instance, I made a [ChaCha20-BLAKE2b][ CHACHA20-Blake2b ] library to allow me to do this.

---

### So When Should You Use An **AEAD**?
*Exceptions to my `Encrypt ➜ MAC` recommendation include when*

<br>

「 **1** 」

Maximum performance is necessary when using public-key cryptography

For example, in online scenarios that don’t involve passwords<br>
and storing data long-term, such as [ TLS 1.3 ] and [ WireGuard ].

This is what **AEADs** are designed for.

---

「 **2** 」

You’re not comfortable implementing `Encrypt ➜ MAC`

If there’s no decent library you can use (**Tink** isn’t available in your language)<br>
or copy code from (make sure you respect the code license!),<br>
then you’re more likely to implement an **AEAD** correctly.

However, implementing the fix I recommend for partitioning oracle attacks<br>
(please see point 9 of the Notes), which affect online password-based encryption<br>
scenarios, requires knowing how to use a **MAC**, so at that point, you may as well<br>
use `Encrypt ➜ MAC`, especially if you’re storing data long-term.

The lack of key commitment could also *theoretically* lead to data loss even when<br>
partitioning oracle attacks aren't a threat (in offline scenarios), meaning you should<br>
also implement the fix if that concerns you, like Amazon has for their [Encryption SDK][ Best Practices ].

With enough research and attention to detail, `Encrypt ➜ MAC` can be implemented correctly by anyone.

---

<br>
<br>

##### 「[ Overview ]」
